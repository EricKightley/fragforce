
void set_force_Vectorized(
    int NumTimes,
    int NumPlanes,
    int NumFacets,
    double forces[NumFacets][3],
    double forces[NumTimes][NumPlanes],
    double aV[NumTimes][3],
    double rotAngles[NumTimes][2],
    double wV[NumTimes][3],
    double pnV[NumPlanes][3],
    double pxV[NumPlanes][3],
    double gammadot,
    double p0,
    double mu,
    double srf_centers_sph[NumFacets][3],
    double srf_crosses_sph[NumFacets][3],
    double srf_normals_sph[NumFacets][3]);

void set_force_Vectorized(
    int NumTimes,
    int NumPlanes,
    int NumFacets,
    double fonfV[NumFacets][3],
    double forces[NumTimes][NumPlanes],
    double aV[NumTimes][3],
    double rotAngles[NumTimes][2],
    double wV[NumTimes][3],
    double pnV_sph[NumPlanes][3],
    double pxV_sph[NumPlanes][3],
    double gammadot,
    double p0,
    double mu,
    double srf_centers_sph[NumFacets][3],
    double srf_crosses_sph[NumFacets][3],
    double srf_normals_sph[NumFacets][3])

/*  Computes the force wrt each timestep and each plane. Takes as input the output of the deformation
    simulation as well as some other constants. forces (what is defined here) is indexed by
    time index (rows) and plane index (cols).  

    Inputs:
        NumTimes         number of timesteps
        NumPlanes        number of intersecting planes
        NumFacets        number of facets on surface triangulation
        fonfV            empty array, to make life easier. at each time step is overwritten
        forces           output array, empty
        aV               each row is the axes lengths at time t
        rotAngles        each row is [cos theta, sin theta] from the rotation
        wV               each row is the angular velocity vector at time t
        pnV_sph          each row is a plane normal, scaled to the sphere
        pnX_sph          each row is a plane point, scaled to the sphere
        gammadot         shear rate
        p0               external pressure
        mu               matrix viscosity
        srf_centers_sph  surface triangulation centers, scaled to sphere
        srf_crosses_sph  surface triangulation edge crosses, scaled to sphere
        srf_normals_sph  surface triangulation normals, scaled to sphere
*/

{
    double L[3][3];
    double farg[3][3];
    double a[3], w[3];
    double c,s;

    //double fonfV[NumFacets][3];
    double srf_centers_scaled[NumFacets][3];
    double srf_areas_scaled[NumFacets];
    double srf_normals_scaled[NumFacets][3];

    double pn[3], px[3] = {0};
    double mag;

    int tstep, pstep, iter_row = 0;
    for ( tstep = 0 ; tstep < NumTimes ; tstep++ )
    {
        // assign the axes and the angular velocity
        for ( iter_row = 0 ; iter_row < 3 ; iter_row++ )
        {
            a[iter_row] = aV[tstep][iter_row];
            w[iter_row] = wV[tstep][iter_row];
        }


        // scale the surface triangulation 
        scale_triangulation(NumFacets, a, srf_centers_scaled, srf_areas_scaled, srf_normals_scaled, 
                            srf_centers_sph, srf_crosses_sph, srf_normals_sph);

        // set up the rotated matrix L
        set_L( L, rotAngles[tstep][0], rotAngles[tstep][1] , gammadot );
        
        //c = rotAngles[tstep][0];
        //s = rotAngles[tstep][1];
        //L[0][0] = -c * s * gammadot;
        //L[0][1] =  c * c * gammadot;
        //L[1][0] = -s * s * gammadot;
        //L[1][1] = -L[0][0];

        // set farg
        set_farg(farg, a, w, L, p0, mu);

        // set the force on the facets    
        set_force_facets(NumFacets, fonfV, farg, srf_normals_scaled, srf_areas_scaled);

        // loop over the planes
        for ( pstep = 0 ; pstep < NumPlanes ; pstep++ )
        {
            // set the plane normal and point
            for (iter_row = 0 ; iter_row < 3 ; iter_row ++)
            {
                pn[iter_row] = pnV_sph[pstep][iter_row];
                px[iter_row] = pxV_sph[pstep][iter_row];
            }

            // scale the plane normal and point
            for (iter_row = 0 ; iter_row < 3 ; iter_row ++)
            {
                pn[iter_row] = pn[iter_row] * a[iter_row];
                px[iter_row] = px[iter_row] * a[iter_row];
            }

            // renormalize the normal
            mag = 0;
            for (iter_row = 0 ; iter_row < 3 ; iter_row ++)
            {
                mag = mag + pn[iter_row] * pn[iter_row];
            }
            // WOULDN'T WANT TO FORGET TO TAKE THE SQUARE ROOT OF THIS WOULD WE?
            // IF WE DID WE MIGHT SPEND SEVERAL DAYS TRYING TO FIND THE ERROR.
            // HAHAHAHAHAHA WOULDN'T THAT BE FUNNY IF THAT HAPPENED?
            // HAHAHAHAHA
            // HAHA
            // ...
            mag = sqrt(mag);
            for (iter_row = 0 ; iter_row < 3 ; iter_row ++)
            {
                pn[iter_row] = pn[iter_row] / mag;
            }


            // compute the force 
            forces[tstep][pstep] = set_force(NumFacets, a, fonfV, srf_centers_scaled, pn, px);
        }

    }
}









# set_force_Vectorized
force.set_force_Vectorized.restype = None
force.set_force_Vectorized.argtypes = [
                         ctypes.c_int,
                         ctypes.c_int,
                         ctypes.c_int,
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ctypes.c_double,
                         ctypes.c_double,
                         ctypes.c_double,
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS"),
                         ndpointer(ctypes.c_double, flags="C_CONTIGUOUS") ]

def py_set_force_Vectorized(aV, rotAngles, wV, pnV, pxV, gammadot, p0, mu):

    [NumTimes, NumPlanes, NumFacets] = [1,1,1]
    if aV.ndim > 1: 
        NumTimes = np.shape(aV)[0]
    if pnV.ndim > 1:
        NumPlanes = np.shape(pnV)[0]
    if srf_centers_sph.ndim > 1:
        NumFacets = np.shape(srf_centers_sph)[0]
    
    forces = np.zeros([NumTimes,NumPlanes])

    fonfV = np.zeros([NumFacets,3])

    force.set_force_Vectorized(
        NumTimes,
        NumPlanes,
        NumFacets,
        np.ascontiguousarray(fonfV),
        np.ascontiguousarray(forces),
        np.ascontiguousarray(aV),
        np.ascontiguousarray(rotAngles),
        np.ascontiguousarray(wV),
        np.ascontiguousarray(pnV),
        np.ascontiguousarray(pxV),
        gammadot,
        p0,
        mu,
        np.ascontiguousarray(srf_centers_sph),
        np.ascontiguousarray(srf_crosses_sph),
        np.ascontiguousarray(srf_normals_sph))

    return forces

###############################################################################
###############################################################################
################               EXTERNAL FUNCTIONS                ##############
###############################################################################
###############################################################################

def frag_force(aV, rotAngles, wV, pnV, pxV, gammadot, p0, mu):
    """ Optimized for efficient computation of fragmentation forces at N different
    time-points and M different times, where N,M >= 1 (so they can be 1). 

    Inputs:
        aV          np.array([N,3]), axes lengths at each time point 
        rotAngles   np.array([N,2]), angles to construct R at each time point
        wV          np.array([N,3]), angular velocity at each time point
        pnV         np.array([M,3]), plane normals
        pxV         np.array([M,3]), plane points
        gammadot    float, shear rate
        p0          float, external pressure
        mu          float, matrix viscosity

    Outputs:
        forces      np.array([N,M]). Rows index time, columns index planes. 
    """

    return py_set_force_Vectorized(aV, rotAngles, wV, pnV, pxV, gammadot, p0, mu)

def surface_forces(a, rotAngles, w, gammadot, p0, mu):
    """ Compute the force on the facets of the surface triangulation. 
    Wrapper for py_set_force_facets that takes more natural inputs and also
    returns the centers of the facets to be used in the fragmentation force 
    computations. Here fonfV can be thought of as the force vector heads 
    and srf_centers_scaled as the force vector tails.

    Note: computes the force (force_density * area of triangle) and not the
          force density. Since the areas are also returned, one can recover
          the force density by taking fonfV / srf_areas_scaled.

    Inputs:
        a          np.array(3)  ellipsoid axes lengths
        w          np.array(3)  angular velocity
        rotAngles  np.array(2)  cos theta, sin theta defining the rotation R. 
                   Note: only a single rotation, not an array of rotations
        gammadot   float  shear rate
        p0         float  external pressure
        mu         float  matrix viscosity

    Outputs:
        farg                  np.array([3,3])  farg (see force.c)
        fonfV                 np.array([N,3])  force vector on each facet
        srf_normals_scaled    np.array([N,3])  normals to facets
        srf_centers_scaled    np.array([N,3])  centers of facets
        srf_areas_scaled      np.array(N)      areas of facets

    """
    # set the velocity gradient in the body frame.
    L = py_set_L(rotAngles,gammadot)
    # scale the surface triangulation quantities
    srf_centers_scaled, srf_areas_scaled, srf_normals_scaled = py_scale_triangulations(a)
    # compute farg
    farg = py_set_farg(a,w,L,p0,mu)
    # get the force on the facets
    fonfV = py_set_force_facets(farg, srf_normals_scaled, srf_areas_scaled)
    return [farg, fonfV, srf_centers_scaled, srf_areas_scaled]
